#!/usr/bin/env python
# encoding: utf-8
# vim: ft=python


import logging
import argparse
import signal
import threading as th
import multiprocessing as mp
import multiprocessing.dummy as mpd
from Queue import Empty as EmptyQueue


DEFAULT_TIMEOUT = 300  # in seconds
WAIT_TIMEOUT = 30      # in seconds
STOPSCAN = mp.Event()


def _process_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', default=None, dest='logconfig',
                        help='config for logging module')
    parser.add_argument('-p', dest='workers', type=int,
                        default=mp.cpu_count(),
                        help='number of worker processes '
                             '(default: number of CPUs)')
    parser.add_argument('-t', default=300, dest='timeout', type=int,
                        help='target scan timeout in seconds (default: 300)')
    parser.add_argument('-P', dest='profile', required=True,
                        help='builtin profile name or path to pw3af file')
    parser.add_argument('targets', type=argparse.FileType(),
                        help='path to file with list of targets')
    return parser.parse_args()


def _get_logger():
    return logging.getLogger(__name__)


def _configure_logging(logconfig):
    if logconfig is not None:
        from logging.config import fileConfig
        fileConfig(logconfig, disable_existing_loggers=False)


def signal_handler(*args):
    STOPSCAN.set()


def run_pool(targets, workers=mpd.cpu_count(), report_queue=None, **kwargs):
    pool = mpd.Pool(workers)
    if report_queue is not None:
        kwargs['report_queue'] = report_queue
    for line in targets:
        target = line.rstrip()
        target_kwargs = kwargs.copy()
        target_kwargs['target'] = target
        pool.apply_async(run_starter, kwds=target_kwargs)
    pool.close()
    pool.join()


def _stop_worker_job(job):
    job.stop()


def run_worker(job, report_queue=None, timeout=DEFAULT_TIMEOUT, **kwargs):
    worker_job=job(**kwargs)
    timer = th.Timer(timeout, _stop_worker_job, args=(worker_job,))
    timer.start()
    worker_job.start()
    timer.cancel()
    if report_queue is not None:
        report_queue.put(worker_job.result())


def _terminate_worker(process):
    if process.is_alive():
        process.terminate()
    logging.getLogger(__name__).debug('Terminate worker')


def run_starter(wait_timeout=WAIT_TIMEOUT, **kwargs):
    wait_timeout = kwargs.get('timeout', DEFAULT_TIMEOUT) + wait_timeout
    process = mp.Process(target=run_worker, kwargs=kwargs)
    timer = th.Timer(wait_timeout, _terminate_worker, args=(process,))
    timer.start()
    process.start()
    process.join()
    timer.cancel()


class W3afJob(object):
    """Create w3afCore object and start w3af scan."""

    def __init__(self, target, profile):
        """W3afJob constructor.

        :param target: target URI
        :param profile: internal w3af profile name or path to *.pw3af file
        """
        from w3af.core.controllers.w3afCore import w3afCore
        from w3af.core.controllers.exceptions import BaseFrameworkException

        self._target = target
        self._profile = profile
        scanner = w3afCore()
        scanner.profiles.use_profile(profile)
        option_list = scanner.target.get_options()
        option_list['target'].set_value(target)
        scanner.target.set_options(option_list)
        scanner.plugins.init_plugins()
        self.scanner = scanner

    def start(self):
        self.scanner.start()

    def stop(self):
        self.scanner.stop()

    def result(self):
        """Return result scan."""
        from w3af.core.data.kb.knowledge_base import kb
        return (self._target, kb.get_all_vulns())


def main():
    """
    Scan a of list of targets from file in parallel.  A pool of manager
    threads is created. Each thread receives a target to scan. Manager
    thread executes scan in a separate process. Scanner process will
    try to stop w3af after timeout seconds. In addition manager thread
    will terminate the child process after WAIT_TIMEOUT seconds.
    """

    args = _process_arguments()
    _configure_logging(args.logconfig)
    report_queue = mp.Queue()
    run_pool(args.targets, job=W3afJob, profile=args.profile,
             report_queue=report_queue)
    while True:
        try:
            target, result = report_queue.get_nowait()
        except EmptyQueue:
            break
        else:
            _get_logger().info('%s: %s', target, result)


if __name__ == '__main__':
    main()
