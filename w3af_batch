#!/usr/bin/env python
# encoding: utf-8


import logging
import argparse
import signal
import threading as th
import multiprocessing as mp
import multiprocessing.dummy as mpd


DEFAULT_TIMEOUT = 300  # in seconds
WAIT_TIMEOUT = 30      # in seconds
STOPSCAN = mp.Event()


def _process_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', default=None, dest='logconfig',
			help='config for logging module')
    parser.add_argument('-p', dest='workers', type=int,
                        default=mp.cpu_count(),
                        help='number of worker processes '
                             '(default: number of CPUs)')
    parser.add_argument('-t', default=300, dest='timeout', type=int,
                        help='target scan timeout in seconds (default: 300)')
    parser.add_argument('-P', dest='profile', required=True,
                        help='builtin profile name or path to pw3af file')
    parser.add_argument('targets', type=argparse.FileType(),
                        help='path to file with list of targets')
    return parser.parse_args()


def _configure_logging(logconfig):
    if logconfig is not None:
	from logging.config import fileConfig
	fileConfig(logconfig, disable_existing_loggers=False)


def _stop_worker_job(job):
    job.stop()


def run_worker(job, report_queue=None, timeout=DEFAULT_TIMEOUT, **kwargs):
    worker_job=job(**kwargs)
    timer = th.Timer(timeout, _stop_worker_job, args=(worker_job,))
    timer.start()
    result = worker_job.start()
    timer.cancel()
    if report_queue is not None:
	report_queue.put(result)


def _terminate_worker(process):
    if process.is_alive():
	process.terminate()
    logging.getLogger(__name__).debug('Terminate worker')


def run_starter(worker, wait_timeout=WAIT_TIMEOUT, **kwargs):
    wait_timeout = kwargs.get('timeout', DEFAULT_TIMEOUT) + wait_timeout
    process = mp.Process(target=worker, kwargs=kwargs)
    timer = th.Timer(wait_timeout, _terminate_worker, args=(process,))
    timer.start()
    process.start()
    process.join()
    timer.cancel()


class W3afJob(object):
    def __init__(self, target, profile):
	from w3af.core.controllers.w3afCore import w3afCore
	from w3af.core.data.kb.knowledge_base import kb
	from w3af.core.controllers.exceptions import BaseFrameworkException

        scanner = w3afCore()
        scanner.profiles.use_profile(profile)
        option_list = scanner.target.get_options()
        option_list['target'].set_value(target)
        scanner.target.set_options(option_list)
        scanner.plugins.init_plugins()
	self.scanner = scanner
	self.running = False

    def start(self):
	self.running = True
	self.scanner.start()
	self.running = False

    def stop(self):
        if self.running or scanner.status.is_running():
	    self.scanner.stop()


def main():
    """
    Scan a of list of targets from file in parallel.  A pool of manager
    threads is created. Each thread receives a target to scan. Manager
    thread executes scan in a separate process. Scanner process will
    try to stop w3af after timeout seconds. In addition manager thread
    will terminate the child process after WAIT_TIMEOUT seconds.
    """

    args = _process_arguments()
    _configure_logging(args.logconfig)
    # FIXME: Remove compulsory report_queue argument
    run_starter(run_worker, job=W3afJob,
	        profile=args.profile, target=args.targets.next().rstrip())


if __name__ == '__main__':
    main()
